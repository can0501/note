# **反射**
1. JAVA 反射机制是在运行状态中，对于任意一个类，都能够$知道$这个类的所有$属性$和$方法$；
2. 对于任意一个对象，都能够$调用$它的任意一个$方法$和$属性$；这种动态获取的信息以及动态调用对象的方法的功能称为 java 语言的反射机制。
## 反射机制优缺点
优点： 运行期类型的判断，动态加载类，提高代码灵活度。
缺点： 
1. **性能瓶颈**：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的 java 代码要慢很多。
2. **安全问题**：让我们可以动态操作改变类的属性同时也增加了类的安全隐患。


   
# BIO,NIO,AIO 总结
 ##  1. BIO (Blocking I/O)
 同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。
 ## 2. NIO (New I/O)
同步非阻塞的I/O模型，3个核心组件：Channel，Selecter，Buffer
- Buffer：读写操作在 Buffer 中进行操作，任何时候访问NIO中的数据，都是通过缓冲区进行操作
- Channel：通过Channel（通道） 进行读写，通道是双向的，可读也可写，通道只能和Buffer交互。因为 Buffer，通道可以异步地读写。
- Selecter：选择器用于使用单个线程处理多个通道，线程切换上下文对于操作系统来说是昂贵，为了提高系统效率选择器是有用的。

## 3. NIO和BIO的
+ NIO面向缓存，BIO面向流
+ 性能NIO>>>>BIO,但是BIO简单开发快
  
# 集合类
## List Set Map 三者的区别:
   + List： 存储的元素是有序的、可重复的。
   + Set: 存储的元素是无序的、不可重复的。
   + Map：使用（kye-value）存储,Key 是无序的、不可重复的，value 是无序的、可重复的。
## Map
+ HashMap:数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的(“拉链法”)。JDK1.8后当链表长度大于8 （将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树），将链表转化为红黑树，以减少搜索时间
+ TreeMap： 红黑树
+ LinkedHashMap： LinkedHashMap 继承自 HashMap,增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序
## ConcurrentHashMap 
+ 1.7由很多个 Segment 组合，而每一个 Segment 是一个类似于 HashMap 的结构，所以每一个 HashMap 的内部可以进行扩容。
     + 默认Segment 16 为final ，表示支持16个线程并发
+ 1.8 Node 数组 + 链表 / 红黑树：使用的 Synchronized 锁加 CAS 的机制，CAS 尝试写入，失败则自旋保证成功。
# 并发
## 进程
+ 进程是程序的一次执行过程，是系统运行程序的基本单位
## 线程
+ 线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程，多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈
## 并发与并行的区别
+ 并发： 同一时间段，多个任务都在执行 
+ 并行： 单位时间内，多个任务同时执行。
## sleep() 方法和 wait() 方法区别和共同点
+ sleep() 方法没有释放锁，而 wait() 方法释放了锁
+ wait() 不加参数线程需要被其他线程notify() 或者 notifyAll() ，sleep（）执行完自动苏醒
+ 两者都可以暂停线程的执行
# 事务
## 隔离级别
1. 脏读：读取了别的事务没有提交修改的数据
2. 不可重复读：一个事务内多次读一份数据，数据不一致，被其他事务**修改**，和脏读区别是其他事务有没有提交
3. 幻读：一个事务多次读取多行，行数不一致，被其他事务新**增行**/**删除**
4. 丢失修改：2个事务修改一份数据，前者的修改丢失

隔离级别	|脏读|	不可重复读|	幻影读
:-|:-|:-|:-
READ-UNCOMMITTED|	√|	√|	√
READ-COMMITTED	|×|	√	|√
REPEATABLE-READ	|×	|×|	√
SERIALIZABLE	|×|	×	|×
# Spring
+ Ioc:将原本在程序中手动创建对象的控制权，交由Spring框架来管理
## Spring-bean的循环依赖以及解决方式
+ 三级缓存，一级缓存：存放已经完成初始化Bean；二级缓存：存在BeanFactory；三级缓存：存放正在实例化的Bean；
+ 过程，A->B ，B->A ，A加载到一级缓存，需要初始化B，从二三缓存拿B，没有则初始化B，B从一，二缓存拿A没有，但是A在三级缓存即B完成初始化，在初始化A，初始化都是反射，所以如果依赖是构造注入那么循环依赖无法解决 

